---
title:  "Чем так плох OpenCart"
date:   2013-11-20 01:59:00
tags:   ["cms", "opencart", "hate"]
layout: "blog/post"
---

Сначала может показаться что все не так уж и плохо: у OpenCart большое, годное сообщество, куча дополнений, шаблонов и прочих свистелок, большой изкоробочный функционал, MVC и даже читаемый код. Ситуация здесь во многом напоминает Joomla, где тоже все хорошо, пока ваша фантазия, фантазия вашего любимого заказчика или менеджера не начинает требовать что-то, что не соответствует мировозрению авторов дивжка.

<!-- cut -->

Девелоперам, особенно тем, кто не просто скачивает готовые шаблоны, здесь приходится туго. Когда дедлайн завтра никто, конечно же, вам не даст взять нормальный фреймворк, потратиь приличное количество времени на разработку и сделать все как надо, а потом еще все это поддерживать. И вы, такие, думаете: «О, опенкарт, да там только шаблон натянуть и в продакшен».

По мере интеграции свежесверстанного шаблона, начинаешь понимать, что ты просто переписываешь большую часть движка заново, чтобы на выходе получить что-то хотя бы примерно соответствующее требованиям технического задания.

## Узкая специализация

Начнем с того, что OpenCart — это система для интернет магазина, то есть магазина и больше ничего. Любая попытка реализовать здесь простенький каталог статей, новостей или чего-нибудь еще, кончится фейлом. Все дополнения, реализующие подобный функционал — просто кривой костыль. Хочешь бложег? А вот хрен, ставь рядом вордпресс и пили такой-же шаблон под него. Unix-way, мать его.

<p style="color:#888;">С одной стороны это, конечно, правильно, не городим лишних велосипедов. Магазин это магазин, блог это блог. Но с другой — суровый российский бизнес хочет чтобы все было сразу и дешево. Подробнее о взгляде на весь этот бардак со стороны разработчика я расскажу как-нибудь в другой раз, а пока, полезем глубже.</p>

## Организация кода

Втоpрая проблема — это организация кода. Админка и фронт, по сути, два разных приложения, со своими шаблонами, контроллерами и моделями. И если с первыми двумя все в порядке, то дублирование моделей это уже перебор. Модели не идентичны, у пользовательской части, например, отсутствуют функции записи в БД, что сделано, наверное, для безопасности, но лучше б ее не было.

Здесь плохо то, что при любом изменении в БД, нам нужно будет изменить как пользовательскую, так и админскую модель, фактически делая одну и ту-же работу два раза (учитывая функцию вставки данных — три раза), причем вслепую копипастить нельзя, запросы могут отличаться.

С плагинами тоже интересная история. Исторически сложилось, что плагин — это такой отдельный юнит, лежащий себе тихо где-нибудь в отдельном уголке. Тут же у нас плагины равномерно размазываются по всей структуре каталогов движка, переплитаясь с другими сущностями, так что выковыривать их потом приходится долго.

## Реализация моделей

Модели — голые генераторы SQL запросов. Запросы собирается прямо таки вручную, конкатенацией строк и, в зависимости от данных во входном массиве, в запрос добавляются новые JOIN'ы. Выглядит это примерно так:

```php
$sql = "SELECT * FROM " . DB_PREFIX . "product p LEFT JOIN " . DB_PREFIX . "product_description pd ON (p.product_id = pd.product_id)";

if (!empty($data['filter_category_id'])) {
  $sql .= " LEFT JOIN " . DB_PREFIX . "product_to_category p2c ON (p.product_id = p2c.product_id)";
}

$sql .= "WHERE pd.language_id = '" . (int)$this->config->get('config_language_id') . "'";

if (!empty($data['filter_name'])) {
  $sql .= " AND pd.name LIKE '%" . $this->db->escape($data['filter_name']) . "%'";
}

// тут еще много всего, да покруче, с циклами
```

Можете начинать скучать по вашей любимой ORM уже сейчас. Но квест «найди незакрытую кавычку в километровом SQL запросе» не даст вам заскучать.


## Спагетти

Контроллеры порадуют вас ну просто зашкаливающей избыточностью кода и лапшой. Например, i18n используется так:

```php
$this->language->load('product/category');

$this->data['button_cart'] = $this->language->get('button_cart');
$this->data['button_wishlist'] = $this->language->get('button_wishlist');
$this->data['button_compare'] = $this->language->get('button_compare');
$this->data['button_continue'] = $this->language->get('button_continue');
$this->data['button_list'] = $this->language->get('button_list');
$this->data['button_grid'] = $this->language->get('button_grid');
```

Причем, `$this->language->load` возвращает нормальный массив, всю эту хрень можно было бы запросто заменить одной строкой:

```php
$this->data['lang'] = $this->language->load('product/category');
```

А внутри шаблонов уже юзать более понятный `$lang['button_cart']`, а не какую-то левую переменную. Почему этого не сделано — не понятно.

## Шаблоны

У меня уже устоявшаяся неприязнь ко всему, где в шаблонах тег открывается в одном файле, а закрывается в другом. — «Наследование? Не, не слышал, давай лучше body откроем в head.php, а закроем в footer.php!»

Все, что попадает в эту категорию, автоматически становится говном с поломанной версткой. Причина понятна, вы видите в файле закрывающий тег, но понятия не имеете, что он закрывает, пока не пробежитесь взглядом по уже отрендеренному шаблону, не найдете там этот тег и его пару, не вспомните, в каком файле вы его открыли.


## Оформление заказов

Чекаут — история, заслуживающая отдельного внимания. Вся система оформления в OpenCart — это квинтэссенция всего зла в мире в одном месте. Процесс оформления заказа кажется вашем пользователям слишком сложным? Хотелось-бы выкинуть эти 100500 полей в пять шагов и оставить простую формочку в корзине? Все просто, вам нужна канистра валерьянки.

Разбираться с тем, что уже написано — нет смысла, там весь процесс завязан на пошаговое оформление. Лучше просто выбросить и писать заново.

## Дружественные URL

То самое ЧПУ, когда в адресной строке вместо нормальных идентификаторов товара отоброжается `ololo-olololo/ololoo/lololo.html`. Оно вроде даже работает, но как-только попытаешься разобраться, придешь в ужас. Похоже что изначально его никто не планировал и ЧПУ просто кое-как накостыляли сеошники.

Принцип работы следующий: если в запросе к драйверу присутствует product_id, значит пользователь обращается к товару, проходимся по иерархии категорий, где лежит товар и генерируем URL. Вроде все просто. Веселье начинается после.

Первое, с чем я столкнулся — драйверу совершенно пофиг, к какому контроллеру вы обращаетесь — если там есть product_id, значит нужно отдать страницу товара. Это вызвало у меня много проблем при разработке OpenCart WEB API, ибо эта тварь отдавала страницу товара, вместо его json объекта.

Второй веселый момент — иерархия категорий это тупо эмуляция. Вы вполне себе можете обратиться к товару прямо из корня сайта, без участия категорий. Это пораждает еще один веселый момент: значения поля для URL должно быть уникальным на весь магазин, не важно, в какой категории находится товар.

## Итог

OpenCart идеален для людей, не знакомых с веб-разработкой, которым требуется быстро поднять работающий каталог. Выгода, в плане использования его в качестве фреймворка для интернет-магазина крайне сомнительна.

Однако, достойных альтернатив и правда нет. Люди, работающие с Zend Framework, Symfony или ROR стоят дорого, времени на разработку уходит много, в условиях российского бизнесса это не катит, а магазин на OpenCart может собрать любой фрилансер за пару вечеров, что большинству и нужно, т.к. «если не видно разницы ...».

По всем этим причинам я не берусь работать с проектами на OpenCart, однако, это не мешает мне писать к нему дополнения. Они хоть немного, да востребованы, а там уже мой родной код и мои родные костыли, которые редко пересекаются с ядром магазина.
